## Arrays and Strings

- Two Pointers: Used for finding pairs or elements that meet specific criteria.
- Sliding Window: Maintains a subset of elements within a larger dataset.
- Binary Search: Efficient searching in sorted arrays.
- Prefix Sum: Precompute cumulative sums for quick range queries.

## Trees

- Depth-First Search (DFS): Preorder, inorder, and postorder traversals.
- Breadth-First Search (BFS): Level-order traversal.
- Binary Search Tree (BST) operations: Insertion, deletion, and validation.
- Tree construction: From preorder/inorder or postorder/inorder traversals.

## Hashtables
- Frequency counting: Track occurrences of elements.
- Two Sum pattern: Find pairs with a specific sum.
- Anagram detection: Compare character frequencies.
- Caching: Store computed results for quick lookup.

## Graphs

- Depth-First Search (DFS): Explore paths deeply before backtracking.
- Breadth-First Search (BFS): Explore nodes level by level.
- Topological Sort: Order nodes in a directed acyclic graph.
- Union Find: Detect cycles and connect components.

## Stacks

- Parentheses matching: Validate balanced brackets.
- Monotonic stack: Maintain increasing/decreasing order for next greater/smaller element problems.
- Expression evaluation: Evaluate arithmetic expressions.

## Queues

- BFS implementation: Level-order traversal in graphs and trees.
- Task scheduling: Manage order of operations.
- Sliding window problems: Maintain a window of elements.

## Heaps

- Top K Elements Pattern: Find or manipulate the K largest/smallest elements in a collection.
- Merge K Sorted Pattern: Combine K sorted lists or arrays into a single sorted list.
- Two Heaps Pattern: Use two heaps to track median or balance elements in a stream.
- Sliding Window Median Pattern: Calculate median in a sliding window over a stream of numbers.
- Scheduling Pattern: Manage tasks or intervals using a heap for efficient scheduling.